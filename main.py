import asyncio
import json
import os
import websocket
import requests
import pandas as pd
from statistics import mean
from telegram import Bot, Update, KeyboardButton, ReplyKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters

# üîπ API-–∫–ª—é—á–∏
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

# üîπ –°–ø–∏—Å–æ–∫ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä (–æ—Å—Ç–∞–≤–ª—è–µ–º –≤—Å–µ –ø–∞—Ä—ã, –∫–∞–∫ –±—ã–ª–æ)
TRADE_PAIRS = ["adausdt", "ipusdt", "tstusdt"]

# üîπ –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ API-—Å–µ—Ä–≤–µ—Ä—ã Binance
BINANCE_API_URLS = [
    "https://fapi.binance.com",
    "https://fapi1.binance.com",
    "https://fapi2.binance.com",
    "https://fapi3.binance.com"
]

def get_available_binance_url():
    """üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫–æ–π API-—Å–µ—Ä–≤–µ—Ä Binance –¥–æ—Å—Ç—É–ø–µ–Ω"""
    for url in BINANCE_API_URLS:
        try:
            response = requests.get(f"{url}/fapi/v1/exchangeInfo", timeout=5)
            if response.status_code == 200:
                print(f"‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ–º Binance API: {url}")
                return url
        except requests.exceptions.RequestException:
            continue
    print("‚ùå –í—Å–µ Binance API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã!")
    exit()

BINANCE_API_URL = get_available_binance_url()

def check_binance_pairs():
    """üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫–∏–µ –ø–∞—Ä—ã —Ç–æ—Ä–≥—É—é—Ç—Å—è –Ω–∞ Binance Futures"""
    print("üîç –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –ø–∞—Ä—ã –Ω–∞ Binance Futures...")
    url = f"{BINANCE_API_URL}/fapi/v1/exchangeInfo"
    try:
        response = requests.get(url, timeout=5)
        if response.status_code == 200:
            data = response.json()
            valid_pairs = [
                pair for pair in TRADE_PAIRS 
                if any(symbol["symbol"].lower() == pair for symbol in data["symbols"])
            ]
            return valid_pairs if valid_pairs else TRADE_PAIRS  # –ï—Å–ª–∏ –ø–∞—Ä –Ω–µ—Ç, –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –±—ã–ª–æ
        else:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ Binance: {response.status_code}")
            return TRADE_PAIRS
    except requests.exceptions.RequestException as e:
        print(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
        return TRADE_PAIRS

# üîπ –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –ø–∞—Ä (–µ—Å–ª–∏ –∫–∞–∫–∏–µ-—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞—é—Ç ‚Äî —É–±–∏—Ä–∞–µ–º)
TRADE_PAIRS = check_binance_pairs()

# üîπ WebSocket Binance Futures
STREAMS = [f"{pair}@kline_5m" for pair in TRADE_PAIRS]
BINANCE_WS_URL = f"wss://fstream.binance.com/stream?streams=" + "/".join(STREAMS)

bot = Bot(token=TELEGRAM_BOT_TOKEN)
candle_data = {pair: pd.DataFrame(columns=["timestamp", "close"]) for pair in TRADE_PAIRS}
last_signal = {pair: None for pair in TRADE_PAIRS}

async def send_telegram_message(text):
    """üîπ –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ Telegram"""
    print(f"üì® Telegram: {text}")
    await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=text)

def calculate_rsi(df, period=14):
    """üîπ –†–∞—Å—Å—á–µ—Ç RSI"""
    delta = df["close"].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
    rs = gain / loss
    rsi = 100 - (100 / (1 + rs))
    return rsi.iloc[-1] if not rsi.empty else None

def calculate_sma(df, period=50):
    """üîπ –†–∞—Å—Å—á–µ—Ç SMA"""
    return df["close"].rolling(window=period).mean().iloc[-1] if not df.empty else None

def calculate_volatility(df, period=20):
    """üîπ –†–∞—Å—Å—á–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏"""
    if len(df) < period:
        return None
    return mean(df["close"].diff().abs().tail(period))

def on_message(ws, message):
    """üîπ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ö–æ–¥—è—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö –∏–∑ WebSocket"""
    data = json.loads(message)

    if "stream" in data and "data" in data:
        stream = data["stream"]
        pair = stream.split("@")[0].upper()
        event_type = stream.split("@")[1]

        if event_type.startswith("kline"):
            price = float(data["data"]["k"]["c"])
            timestamp = data["data"]["k"]["t"]
            is_closed = data["data"]["k"]["x"]

            if is_closed:
                df = candle_data[pair]
                new_row = pd.DataFrame({"timestamp": [timestamp], "close": [price]})
                candle_data[pair] = pd.concat([df, new_row], ignore_index=True)

                if len(candle_data[pair]) > 100:
                    candle_data[pair] = candle_data[pair].iloc[-100:]

                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
                rsi = calculate_rsi(candle_data[pair])
                sma_50 = calculate_sma(candle_data[pair], period=50)
                sma_200 = calculate_sma(candle_data[pair], period=200)
                volatility = calculate_volatility(candle_data[pair])

                # –£—Å–ª–æ–≤–∏—è –¥–ª—è –õ–æ–Ω–≥–∞/–®–æ—Ä—Ç–∞
                signal = ""
                take_profit = None
                stop_loss = None

                if rsi and sma_50 and sma_200 and volatility:
                    risk_factor = round(volatility * 3, 6)  # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –¢–µ–π–∫-–ü—Ä–æ—Ñ–∏—Ç (3x –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏)

                    if rsi < 30 and sma_50 > sma_200:
                        take_profit = round(price + risk_factor, 6)
                        stop_loss = round(price - (risk_factor / 2), 6)
                        signal = f"üöÄ **–õ–æ–Ω–≥ {pair}**\nüí∞ –¶–µ–Ω–∞: {price}\nüéØ TP: {take_profit}\nüõë SL: {stop_loss}\nüìä RSI: {rsi:.2f} | SMA-50 > SMA-200"

                    elif rsi > 70 and sma_50 < sma_200:
                        take_profit = round(price - risk_factor, 6)
                        stop_loss = round(price + (risk_factor / 2), 6)
                        signal = f"‚ö†Ô∏è **–®–æ—Ä—Ç {pair}**\nüí∞ –¶–µ–Ω–∞: {price}\nüéØ TP: {take_profit}\nüõë SL: {stop_loss}\nüìä RSI: {rsi:.2f} | SMA-50 < SMA-200"

                if signal and last_signal[pair] != signal:
                    last_signal[pair] = signal
                    asyncio.run(send_telegram_message(signal))

def start_websocket():
    """üîπ –ó–∞–ø—É—Å–∫ WebSocket"""
    ws = websocket.WebSocketApp(BINANCE_WS_URL, on_message=on_message)
    ws.run_forever()

async def main():
    """üîπ –ó–∞–ø—É—Å–∫ WebSocket –∏ Telegram-–±–æ—Ç–∞"""
    loop = asyncio.get_running_loop()
    websocket_task = loop.run_in_executor(None, start_websocket)
    await websocket_task

if __name__ == "__main__":
    asyncio.run(main(), debug=True)
